#!/data/data/com.termux/files/usr/bin/bash
# HPFA DOCTOR (Termux-safe)
# - no "set -e" (avoid session kill)
# - explicit error handling
set -u

HOME="/data/data/com.termux/files/home"
REPO="$HOME/hpfa"
VENV_PY="$HOME/hpfa/.venv/bin/python"
OUT="$HOME/hpfa/_out"
BASELINE="$HOME/hpfa/_diag/engine_artifacts.CORE.BASELINE.json"
ENVF="$HOME/.config/hpfa/primary.env"
BIN_RUN="$HOME/bin/hpfa-run"
BIN_SET="$HOME/bin/hpfa-set-primary"

say() { printf "%s\n" "$*"; }
ok()  { say "[OK] $*"; }
warn(){ say "[WARN] $*"; }
fail(){ say "[FAIL] $*"; }

hr(){ say "----------------------------------------"; }

# return codes (soft): we accumulate failures but finish report
FAILS=0
bump_fail(){ FAILS=$((FAILS+1)); }

cmd_exists(){ command -v "$1" >/dev/null 2>&1; }

need_file(){
  if [ -f "$1" ]; then ok "file: $1"; else fail "missing file: $1"; bump_fail; fi
}
need_exec(){
  if [ -x "$1" ]; then ok "exec: $1"; else fail "missing/NOT exec: $1"; bump_fail; fi
}
need_dir(){
  if [ -d "$1" ]; then ok "dir: $1"; else fail "missing dir: $1"; bump_fail; fi
}

git_safe(){
  # run git in repo; never abort script on error
  (cd "$REPO" && git "$@") 2>/dev/null
}

show_kv(){ printf "%-18s %s\n" "$1" "$2"; }

hr
say "HPFA DOCTOR"
show_kv "timestamp" "$(date -Is 2>/dev/null || date)"
show_kv "pwd" "$(pwd)"
hr

# 1) Basic paths
need_dir "$REPO"
need_dir "$HOME/.config/hpfa"
need_dir "$HOME/bin"
need_exec "$BIN_RUN"
need_exec "$BIN_SET"
need_dir "$OUT"
need_file "$BASELINE"

# 2) Git repo health
hr
say "GIT HEALTH"
if (cd "$REPO" && git rev-parse --is-inside-work-tree >/dev/null 2>&1); then
  ok "inside work-tree"
  BR="$(git_safe branch --show-current | head -n 1)"
  [ -n "$BR" ] && ok "branch=$BR" || warn "branch=UNKNOWN"

  UP="$(git_safe rev-parse --abbrev-ref @{upstream} | head -n 1)"
  if [ -n "$UP" ]; then ok "upstream=$UP"; else warn "upstream not set"; fi

  S="$(git_safe status -sb | head -n 5)"
  [ -n "$S" ] && say "$S" || warn "git status empty (unexpected)"

  H="$(git_safe rev-parse HEAD | head -n 1)"
  R="$(git_safe rev-parse origin/main | head -n 1)"
  if [ -n "$H" ] && [ -n "$R" ]; then
    if [ "$H" = "$R" ]; then ok "HEAD == origin/main"; else warn "HEAD != origin/main"; bump_fail; fi
  else
    warn "cannot read HEAD/origin/main"; bump_fail
  fi

  # tag check (if exists)
  if git_safe rev-parse hpfa-stable-20260217^{}/null >/dev/null 2>&1; then :; fi
  T="$(git_safe rev-parse hpfa-stable-20260217^{} | head -n 1)"
  if [ -n "$T" ] && [ -n "${H:-}" ]; then
    if [ "$T" = "$H" ]; then ok "tag hpfa-stable-20260217 == HEAD"; else warn "tag != HEAD"; bump_fail; fi
  else
    warn "tag hpfa-stable-20260217 not found (ok if you renamed)"; 
  fi

  # divergence (non-fatal)
  CNT="$(git_safe rev-list --left-right --count origin/main...HEAD | tr -s ' ' | head -n 1)"
  [ -n "$CNT" ] && ok "divergence(origin/main...HEAD)=$CNT" || warn "cannot compute divergence"
else
  fail "not a git repo: $REPO"
  bump_fail
fi

# 3) PATH + command resolution
hr
say "COMMAND RESOLUTION"
if cmd_exists hpfa-run; then ok "hpfa-run=$(command -v hpfa-run)"; else fail "hpfa-run not on PATH"; bump_fail; fi
if cmd_exists hpfa-set-primary; then ok "hpfa-set-primary=$(command -v hpfa-set-primary)"; else fail "hpfa-set-primary not on PATH"; bump_fail; fi
ok "PATH(head)=$(printf '%s' "$PATH" | cut -c1-120)"

# 4) PRIMARY_DIR persisted env
hr
say "PRIMARY DIR"
if [ -f "$ENVF" ]; then
  ok "envfile=$ENVF"
  # shellcheck disable=SC1090
  . "$ENVF" 2>/dev/null || true
  if [ -n "${PRIMARY_DIR:-}" ] && [ -d "${PRIMARY_DIR:-}" ]; then
    ok "PRIMARY_DIR=$PRIMARY_DIR"
  else
    warn "PRIMARY_DIR invalid or empty: ${PRIMARY_DIR:-EMPTY}"
    bump_fail
  fi
else
  warn "no envfile: $ENVF (run hpfa-set-primary ...)"
  bump_fail
fi

# 5) Python/venv/import health (SSOT)
hr
say "PYTHON HEALTH"
if [ -x "$VENV_PY" ]; then
  ok "venv python=$VENV_PY"
  "$VENV_PY" - <<'PY' 2>/dev/null || exit 13
import sys
import hpfa, hp_motor
print("[OK] hpfa.__file__=", hpfa.__file__)
print("[OK] hp_motor.__file__=", hp_motor.__file__)
print("[OK] sys.path(head)=", sys.path[:7])
PY
  RC=$?
  if [ "$RC" -eq 0 ]; then ok "imports OK"; else fail "imports failed (rc=$RC)"; bump_fail; fi
else
  fail "missing venv python: $VENV_PY"
  bump_fail
fi

# 6) Baseline fingerprint read
hr
say "CORE BASELINE"
FP=""
if [ -f "$BASELINE" ]; then
  # tolerant parse: grep fingerprint_sha256
  FP="$(grep -Eo '"fingerprint_sha256"[[:space:]]*:[[:space:]]*"[^"]+"' "$BASELINE" 2>/dev/null | head -n 1 | sed -E 's/.*"([^"]+)".*/\1/')"
  if [ -n "$FP" ]; then ok "fingerprint_sha256=$FP"; else warn "fingerprint not found in baseline"; bump_fail; fi
else
  fail "baseline missing: $BASELINE"; bump_fail
fi

# 7) Guarded run (tail)
hr
say "GUARDED RUN (tail)"
if cmd_exists hpfa-run; then
  # do not fail whole doctor if run fails; just record
  OUTLOG="$(mktemp 2>/dev/null || echo "$HOME/.config/hpfa/_doctor_tmp.log")"
  (hpfa-run >"$OUTLOG" 2>&1) || true
  # show last lines
  tail -n 18 "$OUTLOG" 2>/dev/null || true
  # minimal success predicate
  if grep -q 'RUN_GUARDED_COMPLETE' "$OUTLOG" 2>/dev/null; then
    ok "guarded run COMPLETE"
  else
    warn "guarded run did not reach COMPLETE"
    bump_fail
  fi
  rm -f "$OUTLOG" 2>/dev/null || true
else
  fail "hpfa-run not available"; bump_fail
fi

# 8) OUT runs quick stats
hr
say "OUT HEALTH"
if [ -d "$OUT" ]; then
  CNT="$(find "$OUT" -maxdepth 1 -type d -name 'engine_run_*' 2>/dev/null | wc -l | tr -d ' ')"
  ok "engine_run_* count=$CNT"
  find "$OUT" -maxdepth 1 -type d -name 'engine_run_*' \
    -printf "%T@\t%TY-%Tm-%Td %TH:%TM:%TS\t%f\n" 2>/dev/null \
    | sort -nr | head -n 5 | awk -F"\t" '{print "  " $2 "  " $3}'
else
  warn "OUT missing"; bump_fail
fi

hr
if [ "$FAILS" -eq 0 ]; then
  ok "DOCTOR_RESULT=PASS"
  exit 0
else
  warn "DOCTOR_RESULT=FAIL (fails=$FAILS)"
  exit 10
fi
